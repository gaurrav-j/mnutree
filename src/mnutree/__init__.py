# -*- coding: utf-8 -*-
"""The menu tree module file.
   The file is auto-generated by pyscaffolding
   The file is modified to include logging construct which
   is common across all files.
"""
import os
import sys
import logging
import argparse

from pkg_resources import get_distribution, DistributionNotFound

try:
    # Change here if project is renamed and does not equal the package name
    DIST_NAME = __name__
    __version__ = get_distribution(DIST_NAME).version
except DistributionNotFound:
    __version__ = 'unknown'
finally:
    del get_distribution, DistributionNotFound

def is_valid_file(parser, arg):
    """The method to check if the file path is valid file.
       The file path is provided from command line
    """
    if not os.path.exists(arg):
        parser.error("The menu file %s does not exist!" % arg)
    else:
        with open(arg, 'r') as data_file:
            if data_file.readable:
                return arg
    return None


def parse_args(args):
    """Parse command line parameters

       Parameters
       ----------
       args: ([str])
        command line parameters as list of strings

       Returns
       -------
       :obj:`argparse.Namespace`
        command line parameters namespace
    """
    parser = argparse.ArgumentParser(description="The utility to convert structured csv to JSON")

    parser.add_argument(dest="csv_file", help="input csv file with menu data",
                        metavar="FILE", default="data.csv", nargs='?',
                        const=1, type=lambda x: is_valid_file(parser, x))

    parser.add_argument("--version", action="version",
                        version="menucsv {ver}".format(ver=__version__),
    )

    parser.add_argument("-v", "--verbose",
                        dest="loglevel", help="set loglevel to INFO",
                        action="store_const", const=logging.INFO,
    )

    parser.add_argument("-vv", "--very-verbose",
                        dest="loglevel", help="set loglevel to DEBUG",
                        action="store_const", const=logging.DEBUG,
    )

    return parser.parse_args(args)


def setup_logging(loglevel):
    """Setup basic logging

       Parameters
       ----------
       loglevel: int
        minimum loglevel for emitting messages
    """
    logformat = "[%(asctime)s] %(levelname)s:%(name)s:%(message)s"

    logging.basicConfig(
        level=loglevel, stream=sys.stdout, format=logformat, datefmt="%Y-%m-%d %H:%M:%S"
    )

__logger__ = logging.getLogger(__name__)

# the method is to be evolved furthur
def info(message, *values, debug=False):
    """The unified logging construct

      The method to control the logging in the application.

      Parameters
      ----------
      message : string
          the logging message

      *values: non-keyworded, variable-length argument list
            the values used in the format method the string

      debug: boolean
            the default is false, so log level is info by default
            true will enable debug level
    """
    if len(values) == 0:
        if debug:
            __logger__.debug(message)
        else: __logger__.info(message)
    else:
        if debug :
            __logger__.debug(message.format(*values))
        else:
            __logger__.info(message.format(*values))
