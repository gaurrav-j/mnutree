# -*- coding: utf-8 -*-
"""The menu tree module file.
   The file is auto-generated by pyscaffolding
   The file is modified to include logging construct which
   is common across all files.
"""
import os
import sys
import logging
from logging import Logger, getLogger
from argparse import ArgumentParser, Namespace
from typing import List, Tuple, Sequence, Optional, TextIO, Generator
import tempfile
from contextlib import contextmanager

from pkg_resources import get_distribution, DistributionNotFound

try:
    # Change here if project is renamed and does not equal the package name
    DIST_NAME: str = __name__
    __version__: str = get_distribution(DIST_NAME).version
except DistributionNotFound:
    __version__ = 'unknown'
finally:
    del get_distribution, DistributionNotFound

def is_valid_file(parser: ArgumentParser, arg: str) -> Optional[str]:
    """The method to check if the file path is valid file.
       The file path is provided from command line
    """
    if not os.path.exists(arg) and arg.find("/") > -1:
        parser.error("The menu file %s does not exist!" % arg)
        return None
    else:
        if arg.find("/") > -1:
            data_file: TextIO
            with open(arg, 'r') as data_file:
                if not data_file.readable:
                    parser.error("The menu file %s is not readable!" % arg)
                    return None
    return arg


def parse_args(args: Optional[Sequence[str]]) -> Namespace:
    """Parse command line parameters

       Parameters
       ----------
       args: ([str])
        command line parameters as list of strings

       Returns
       -------
       :obj:`argparse.Namespace`
        command line parameters namespace
    """
    parser: ArgumentParser = ArgumentParser(description
        ="The utility to convert structured csv to JSON")

    parser.add_argument(dest="csv_file", help="input csv file with menu data",
                        metavar="FILE", default="data.csv", nargs='?',
                        const=1, type=lambda x: is_valid_file(parser, x))

    parser.add_argument("--version", action="version",
                        version="menucsv {ver}".format(ver=__version__),
    )

    parser.add_argument("-v", "--verbose",
                        dest="loglevel", help="set loglevel to INFO",
                        action="store_const", const=logging.INFO,
    )

    parser.add_argument("-vv", "--very-verbose",
                        dest="loglevel", help="set loglevel to DEBUG",
                        action="store_const", const=logging.DEBUG,
    )

    return parser.parse_args(args)


def setup_logging(loglevel: int) -> None:
    """Setup basic logging

       Parameters
       ----------
       loglevel: int
        minimum loglevel for emitting messages
    """
    logformat: str = "[%(asctime)s] %(levelname)s:%(name)s:%(message)s"

    logging.basicConfig(
        level=loglevel, stream=sys.stdout, format=logformat, datefmt="%Y-%m-%d %H:%M:%S"
    )

__logger__ : Logger = getLogger(__name__)

# the method is to be evolved furthur
def info(message: str, *values: object, debug: bool=False) -> None:
    """The unified logging construct

      The method to control the logging in the application.

      Parameters
      ----------
      message : string
          the logging message

      *values: non-keyworded, variable-length argument list
            the values used in the format method the string

      debug: boolean
            the default is false, so log level is info by default
            true will enable debug level
    """
    if len(values) == 0:
        if debug:
            __logger__.debug(message)
        else: __logger__.info(message)
    else:
        if debug :
            __logger__.debug(message.format(*values))
        else:
            __logger__.info(message.format(*values))


@contextmanager
def strfile(data: str) -> Generator:
    """The temp file context manager
    """
    temp = tempfile.NamedTemporaryFile(delete=False)
    config_path = f'{temp.name}.csv'
    with open(config_path, 'w') as file:
        file.write(data)
    try:
        yield f'{temp.name}.csv'
    finally:
        temp.close()
        os.unlink(temp.name)


FILE_STR = """Base URL,Level 1 - Name,Level 1 - ID,Level 1 - URL,Level 2 - Name,Level 2 - ID,\
    Level 2 URL,Level 3 - Name,Level 3 - ID,Level 3 URL
https://groceries.morrisons.com/browse,THE BEST,178974,https://groceries.morrisons.com/browse/178974,,,,,,
,,,,,,,,,
https://groceries.morrisons.com/browse,THE BEST,178974,https://groceries.morrisons.com/browse/178974,FRESH,178969,https://groceries.morrisons.com/browse/178974/178969,,,
https://groceries.morrisons.com/browse,THE BEST,178974,https://groceries.morrisons.com/browse/178974,FRESH,178969,https://groceries.morrisons.com/browse/178974/178969,CHEESE,178975,https://groceries.morrisons.com/browse/178974/178969/178975
https://groceries.morrisons.com/browse,THE BEST,178974,https://groceries.morrisons.com/browse/178974,FRESH,178969,https://groceries.morrisons.com/browse/178974/178969,COOKED MEAT & ANTIPASTI,178976,https://groceries.morrisons.com/browse/178974/178969/178976
https://groceries.morrisons.com/browse,THE BEST,178974,https://groceries.morrisons.com/browse/178974,FRESH,178969,https://groceries.morrisons.com/browse/178974/178969,DAIRY & EGGS,178977,https://groceries.morrisons.com/browse/178974/178969/178977
https://groceries.morrisons.com/browse,THE BEST,178974,https://groceries.morrisons.com/browse/178974,FRESH,178969,https://groceries.morrisons.com/browse/178974/178969,DESSERTS,178978,https://groceries.morrisons.com/browse/178974/178969/178978
https://groceries.morrisons.com/browse,THE BEST,178974,https://groceries.morrisons.com/browse/178974,FRESH,178969,https://groceries.morrisons.com/browse/178974/178969,DRINKS,178979,https://groceries.morrisons.com/browse/178974/178969/178979
"""