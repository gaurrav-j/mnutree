# -*- coding: utf-8 -*-
"""The menu tree module file.
   The file is auto-generated by pyscaffolding
   The file is modified to include logging construct which
   is common across all files.
"""
import os
import sys
import logging
from argparse import ArgumentParser, Namespace
from typing import List, Tuple, Sequence, Optional

from pkg_resources import get_distribution, DistributionNotFound

try:
    # Change here if project is renamed and does not equal the package name
    DIST_NAME = __name__
    __version__ = get_distribution(DIST_NAME).version
except DistributionNotFound:
    __version__ = 'unknown'
finally:
    del get_distribution, DistributionNotFound

def is_valid_file(parser: ArgumentParser, arg: str) -> Optional[str]:
    """The method to check if the file path is valid file.
       The file path is provided from command line
    """
    if not os.path.exists(arg):
        parser.error("The menu file %s does not exist!" % arg)
    else:
        with open(arg, 'r') as data_file:
            if data_file.readable:
                return arg
    return None


def parse_args(args: Optional[Sequence[str]]) -> Namespace:
    """Parse command line parameters

       Parameters
       ----------
       args: ([str])
        command line parameters as list of strings

       Returns
       -------
       :obj:`argparse.Namespace`
        command line parameters namespace
    """
    parser: ArgumentParser = ArgumentParser(description
        ="The utility to convert structured csv to JSON")

    parser.add_argument(dest="csv_file", help="input csv file with menu data",
                        metavar="FILE", default="data.csv", nargs='?',
                        const=1, type=lambda x: is_valid_file(parser, x))

    parser.add_argument("--version", action="version",
                        version="menucsv {ver}".format(ver=__version__),
    )

    parser.add_argument("-v", "--verbose",
                        dest="loglevel", help="set loglevel to INFO",
                        action="store_const", const=logging.INFO,
    )

    parser.add_argument("-vv", "--very-verbose",
                        dest="loglevel", help="set loglevel to DEBUG",
                        action="store_const", const=logging.DEBUG,
    )

    return parser.parse_args(args)


def setup_logging(loglevel: int) -> None:
    """Setup basic logging

       Parameters
       ----------
       loglevel: int
        minimum loglevel for emitting messages
    """
    logformat: str = "[%(asctime)s] %(levelname)s:%(name)s:%(message)s"

    logging.basicConfig(
        level=loglevel, stream=sys.stdout, format=logformat, datefmt="%Y-%m-%d %H:%M:%S"
    )

__logger__ = logging.getLogger(__name__)

# the method is to be evolved furthur
def info(message: str, *values: object, debug: bool=False) -> None:
    """The unified logging construct

      The method to control the logging in the application.

      Parameters
      ----------
      message : string
          the logging message

      *values: non-keyworded, variable-length argument list
            the values used in the format method the string

      debug: boolean
            the default is false, so log level is info by default
            true will enable debug level
    """
    if len(values) == 0:
        if debug:
            __logger__.debug(message)
        else: __logger__.info(message)
    else:
        if debug :
            __logger__.debug(message.format(*values))
        else:
            __logger__.info(message.format(*values))
